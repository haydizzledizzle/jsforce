{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/api/bulk.js","node_modules/process/browser.js"],"names":["f","g","exports","module","define","amd","window","global","self","this","jsforce","modules","api","Bulk","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","Job","bulk","type","operation","options","jobId","_bulk","id","state","_batches","inherits","stream","Duplex","events","_","joinStreams","RecordStream","Promise","HttpApi","EventEmitter","prototype","info","callback","_jobInfo","check","thenCall","open","body","_logger","toLowerCase","extIdField","concurrencyMode","assignmentRuleId","join","_request","method","path","headers","Content-Type","Sforce-Enable-PKChunking","pkChunking","chunkSize","responseType","then","res","emit","jobInfo","err","createBatch","batch","Batch","on","batchId","logger","_waitAssign","debug","object","resolve","list","batchInfoList","batchInfo","isArray","close","_changeState","abort","job","super_","objectMode","_deferred","defer","_setupDataStreams","Writable","converterOptions","nullValue","_uploadStream","Serializable","_uploadDataStream","_downloadStream","Parsable","_downloadDataStream","end","once","pipe","_createRequestStream","dataStream","_dataStream","_write","data","enc","cb","write","read","push","_read","size","chunk","record","clone","Id","attributes","run","exec","execute","input","_result","rdeferred","promise","reject","isObject","isFunction","forEach","Object","keys","key","String","isString","onResolved","onReject","onProgress","process","nextTick","poll","interval","timeout","startTime","Date","getTime","now","name","parseInt","numberRecordsProcessed","retrieve","stateMessage","pollHandle","setTimeout","pollStop","clearTimeout","undefined","results","_conn","result","map","ret","success","Success","errors","fail","resultId","resultStream","resultDataStream","BulkApi","apply","arguments","beforeSend","request","accessToken","isSessionExpired","response","statusCode","test","hasErrorInResponseBody","error","parseError","errorCode","exceptionCode","message","exceptionMessage","conn","pollInterval","pollTimeout","baseUrl","instanceUrl","version","url","load","constructor","createJob","isChunking","cleanup","pollBatches","batches","filter","every","all","flatten","failedBatch","find","progress","query","soql","m","replace","match","recordStream","streams","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","len","marker","runClearTimeout","Item","array","noop","args","Array","title","browser","env","argv","versions","addListener","off","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"jsforce-api-bulk.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*global process*/\r\n/**\r\n * @file Manages Salesforce Bulk API related operations\r\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\r\n */\r\n\r\n'use strict';\r\n\r\nvar inherits     = window.jsforce.require('inherits'),\r\n    stream       = window.jsforce.require('readable-stream'),\r\n    Duplex       = stream.Duplex,\r\n    events       = window.jsforce.require('events'),\r\n    _            = window.jsforce.require('lodash/core'),\r\n    joinStreams  = window.jsforce.require('multistream'),\r\n    jsforce      = window.jsforce.require('./core'),\r\n    RecordStream = window.jsforce.require('./record-stream'),\r\n    Promise      = window.jsforce.require('./promise'),\r\n    HttpApi      = window.jsforce.require('./http-api');\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Class for Bulk API Job\r\n *\r\n * @protected\r\n * @class Bulk~Job\r\n * @extends events.EventEmitter\r\n *\r\n * @param {Bulk} bulk - Bulk API object\r\n * @param {String} [type] - SObject type\r\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\r\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\r\n * @param {String} [jobId] - Job ID (if already available)\r\n */\r\nvar Job = function(bulk, type, operation, options, jobId) {\r\n  this._bulk = bulk;\r\n  this.type = type;\r\n  this.operation = operation;\r\n  this.options = options || {};\r\n  this.id = jobId;\r\n  this.state = this.id ? 'Open' : 'Unknown';\r\n  this._batches = {};\r\n};\r\n\r\ninherits(Job, events.EventEmitter);\r\n\r\n/**\r\n * @typedef {Object} Bulk~JobInfo\r\n * @prop {String} id - Job ID\r\n * @prop {String} object - Object type name\r\n * @prop {String} operation - Operation type of the job\r\n * @prop {String} state - Job status\r\n */\r\n\r\n/**\r\n * Return latest jobInfo from cache\r\n *\r\n * @method Bulk~Job#info\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.info = function(callback) {\r\n  var self = this;\r\n  // if cache is not available, check the latest\r\n  if (!this._jobInfo) {\r\n    this._jobInfo = this.check();\r\n  }\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Open new job and get jobinfo\r\n *\r\n * @method Bulk~Job#open\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.open = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  // if not requested opening job\r\n  if (!this._jobInfo) {\r\n    var operation = this.operation.toLowerCase();\r\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\r\n    var body = [\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\r\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\r\n        '<operation>' + operation + '</operation>',\r\n        '<object>' + this.type + '</object>',\r\n        (this.options.extIdField ?\r\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\r\n         ''),\r\n        (this.options.concurrencyMode ?\r\n         '<concurrencyMode>'+this.options.concurrencyMode+'</concurrencyMode>' :\r\n         ''),\r\n        (this.options.assignmentRuleId ?\r\n          '<assignmentRuleId>' + this.options.assignmentRuleId + '</assignmentRuleId>' :\r\n          ''),\r\n        '<contentType>CSV</contentType>',\r\n      '</jobInfo>'\r\n    ].join('');\r\n\r\n    this._jobInfo = bulk._request({\r\n      method : 'POST',\r\n      path : \"/job\",\r\n      body : body,\r\n      headers : {\r\n        \"Content-Type\" : \"application/xml; charset=utf-8\",\r\n        \"Sforce-Enable-PKChunking\": (this.options.pkChunking || this.options.chunkSize) ? \r\n          (this.options.chunkSize ? \"chunkSize=\" + this.options.chunkSize : \"true\"): \"false\"\r\n      },\r\n      responseType: \"application/xml\"\r\n    }).then(function(res) {\r\n      self.emit(\"open\", res.jobInfo);\r\n      self.id = res.jobInfo.id;\r\n      self.state = res.jobInfo.state;\r\n      return res.jobInfo;\r\n    }, function(err) {\r\n      self.emit(\"error\", err);\r\n      throw err;\r\n    });\r\n  }\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Create a new batch instance in the job\r\n *\r\n * @method Bulk~Job#createBatch\r\n * @returns {Bulk~Batch}\r\n */\r\nJob.prototype.createBatch = function() {\r\n  var batch = new Batch(this);\r\n  var self = this;\r\n  batch.on('queue', function() {\r\n    self._batches[batch.id] = batch;\r\n  });\r\n  return batch;\r\n};\r\n\r\n/**\r\n * Get a batch instance specified by given batch ID\r\n *\r\n * @method Bulk~Job#batch\r\n * @param {String} batchId - Batch ID\r\n * @returns {Bulk~Batch}\r\n */\r\nJob.prototype.batch = function(batchId) {\r\n  var batch = this._batches[batchId];\r\n  if (!batch) {\r\n    batch = new Batch(this, batchId);\r\n    this._batches[batchId] = batch;\r\n  }\r\n  return batch;\r\n};\r\n\r\n/**\r\n * Check the latest job status from server\r\n *\r\n * @method Bulk~Job#check\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.check = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  this._jobInfo = this._waitAssign().then(function() {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + self.id,\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.jobInfo);\r\n    self.id = res.jobInfo.id;\r\n    self.type = res.jobInfo.object;\r\n    self.operation = res.jobInfo.operation;\r\n    self.state = res.jobInfo.state;\r\n    return res.jobInfo;\r\n  });\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Wait till the job is assigned to server\r\n *\r\n * @method Bulk~Job#info\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype._waitAssign = function(callback) {\r\n  return (this.id ? Promise.resolve({ id: this.id }) : this.open()).thenCall(callback);\r\n};\r\n\r\n\r\n/**\r\n * List all registered batch info in job\r\n *\r\n * @method Bulk~Job#list\r\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\r\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\r\n */\r\nJob.prototype.list = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  return this._waitAssign().then(function() {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + self.id + \"/batch\",\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.batchInfoList.batchInfo);\r\n    var batchInfoList = res.batchInfoList;\r\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\r\n    return batchInfoList;\r\n  }).thenCall(callback);\r\n\r\n};\r\n\r\n/**\r\n * Close opened job\r\n *\r\n * @method Bulk~Job#close\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.close = function() {\r\n  var self = this;\r\n  return this._changeState(\"Closed\").then(function(jobInfo) {\r\n    self.id = null;\r\n    self.emit(\"close\", jobInfo);\r\n    return jobInfo;\r\n  }, function(err) {\r\n    self.emit(\"error\", err);\r\n    throw err;\r\n  });\r\n};\r\n\r\n/**\r\n * Set the status to abort\r\n *\r\n * @method Bulk~Job#abort\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.abort = function() {\r\n  var self = this;\r\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\r\n    self.id = null;\r\n    self.emit(\"abort\", jobInfo);\r\n    return jobInfo;\r\n  }, function(err) {\r\n    self.emit(\"error\", err);\r\n    throw err;\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nJob.prototype._changeState = function(state, callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  this._jobInfo = this._waitAssign().then(function() {\r\n    var body = [\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\r\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\r\n        '<state>' + state + '</state>',\r\n      '</jobInfo>'\r\n    ].join('');\r\n    return bulk._request({\r\n      method : 'POST',\r\n      path : \"/job/\" + self.id,\r\n      body : body,\r\n      headers : {\r\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\r\n      },\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.jobInfo);\r\n    self.state = res.jobInfo.state;\r\n    return res.jobInfo;\r\n  });\r\n  return this._jobInfo.thenCall(callback);\r\n\r\n};\r\n\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Batch (extends RecordStream)\r\n *\r\n * @protected\r\n * @class Bulk~Batch\r\n * @extends {stream.Writable}\r\n * @implements {Promise.<Array.<RecordResult>>}\r\n * @param {Bulk~Job} job - Bulk job object\r\n * @param {String} [batchId] - Batch ID (if already available)\r\n */\r\nvar Batch = function(job, batchId) {\r\n  Batch.super_.call(this, { objectMode: true });\r\n  this.job = job;\r\n  this.id = batchId;\r\n  this._bulk = job._bulk;\r\n  this._deferred = Promise.defer();\r\n  this._setupDataStreams();\r\n};\r\n\r\ninherits(Batch, stream.Writable);\r\n\r\n\r\n/**\r\n * @private\r\n */\r\nBatch.prototype._setupDataStreams = function() {\r\n  var batch = this;\r\n  var converterOptions = { nullValue : '#N/A' };\r\n  this._uploadStream = new RecordStream.Serializable();\r\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\r\n  this._downloadStream = new RecordStream.Parsable();\r\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\r\n\r\n  this.on('finish', function() {\r\n    batch._uploadStream.end();\r\n  });\r\n  this._uploadDataStream.once('readable', function() {\r\n    batch.job.open().then(function() {\r\n      // pipe upload data to batch API request stream\r\n      batch._uploadDataStream.pipe(batch._createRequestStream());\r\n    });\r\n  });\r\n\r\n  // duplex data stream, opened access to API programmers by Batch#stream()\r\n  var dataStream = this._dataStream = new Duplex();\r\n  dataStream._write = function(data, enc, cb) {\r\n    batch._uploadDataStream.write(data, enc, cb);\r\n  };\r\n  dataStream.on('finish', function() {\r\n    batch._uploadDataStream.end();\r\n  });\r\n\r\n  this._downloadDataStream.on('readable', function() {\r\n    dataStream.read(0);\r\n  });\r\n  this._downloadDataStream.on('end', function() {\r\n    dataStream.push(null);\r\n  });\r\n  dataStream._read = function(size) {\r\n    var chunk;\r\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\r\n      dataStream.push(chunk);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Connect batch API and create stream instance of request/response\r\n *\r\n * @private\r\n * @returns {stream.Duplex}\r\n */\r\nBatch.prototype._createRequestStream = function() {\r\n  var batch = this;\r\n  var bulk = batch._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  return bulk._request({\r\n    method : 'POST',\r\n    path : \"/job/\" + batch.job.id + \"/batch\",\r\n    headers: {\r\n      \"Content-Type\": \"text/csv\"\r\n    },\r\n    responseType: \"application/xml\"\r\n  }, function(err, res) {\r\n    if (err) {\r\n      batch.emit('error', err);\r\n    } else {\r\n      logger.debug(res.batchInfo);\r\n      batch.id = res.batchInfo.id;\r\n      batch.emit('queue', res.batchInfo);\r\n    }\r\n  }).stream();\r\n};\r\n\r\n/**\r\n * Implementation of Writable\r\n *\r\n * @override\r\n * @private\r\n */\r\nBatch.prototype._write = function(record, enc, cb) {\r\n  record = _.clone(record);\r\n  if (this.job.operation === \"insert\") {\r\n    delete record.Id;\r\n  } else if (this.job.operation === \"delete\") {\r\n    record = { Id: record.Id };\r\n  }\r\n  delete record.type;\r\n  delete record.attributes;\r\n  this._uploadStream.write(record, enc, cb);\r\n};\r\n\r\n/**\r\n * Returns duplex stream which accepts CSV data input and batch result output\r\n *\r\n * @returns {stream.Duplex}\r\n */\r\nBatch.prototype.stream = function() {\r\n  return this._dataStream;\r\n};\r\n\r\n/**\r\n * Execute batch operation\r\n *\r\n * @method Bulk~Batch#execute\r\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\r\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Bulk~Batch}\r\n */\r\nBatch.prototype.run =\r\nBatch.prototype.exec =\r\nBatch.prototype.execute = function(input, callback) {\r\n  var self = this;\r\n\r\n  if (typeof input === 'function') { // if input argument is omitted\r\n    callback = input;\r\n    input = null;\r\n  }\r\n\r\n  // if batch is already executed\r\n  if (this._result) {\r\n    throw new Error(\"Batch already executed.\");\r\n  }\r\n\r\n  var rdeferred = Promise.defer();\r\n  this._result = rdeferred.promise;\r\n  this._result.then(function(res) {\r\n    self._deferred.resolve(res);\r\n  }, function(err) {\r\n    self._deferred.reject(err);\r\n  });\r\n  this.once('response', function(res) {\r\n    rdeferred.resolve(res);\r\n  });\r\n  this.once('error', function(err) {\r\n    rdeferred.reject(err);\r\n  });\r\n\r\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\r\n    input.pipe(this._dataStream);\r\n  } else {\r\n    var data;\r\n    if (_.isArray(input)) {\r\n      _.forEach(input, function(record) {\r\n        Object.keys(record).forEach(function(key) {\r\n          if (typeof record[key] === 'boolean') {\r\n            record[key] = String(record[key])\r\n          }\r\n        })\r\n        self.write(record);\r\n      });\r\n      self.end();\r\n    } else if (_.isString(input)){\r\n      data = input;\r\n      this._dataStream.write(data, 'utf8');\r\n      this._dataStream.end();\r\n    }\r\n  }\r\n\r\n  // return Batch instance for chaining\r\n  return this.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Promise/A+ interface\r\n * http://promises-aplus.github.io/promises-spec/\r\n *\r\n * Delegate to deferred promise, return promise instance for batch result\r\n *\r\n * @method Bulk~Batch#then\r\n */\r\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\r\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\r\n};\r\n\r\n/**\r\n * Promise/A+ extension\r\n * Call \"then\" using given node-style callback function\r\n *\r\n * @method Bulk~Batch#thenCall\r\n */\r\nBatch.prototype.thenCall = function(callback) {\r\n  if (_.isFunction(callback)) {\r\n    this.then(function(res) {\r\n      process.nextTick(function() {\r\n        callback(null, res);\r\n      });\r\n    }, function(err) {\r\n      process.nextTick(function() {\r\n        callback(err);\r\n      });\r\n    });\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * @typedef {Object} Bulk~BatchInfo\r\n * @prop {String} id - Batch ID\r\n * @prop {String} jobId - Job ID\r\n * @prop {String} state - Batch state\r\n * @prop {String} stateMessage - Batch state message\r\n */\r\n\r\n/**\r\n * Check the latest batch status in server\r\n *\r\n * @method Bulk~Batch#check\r\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~BatchInfo>}\r\n */\r\nBatch.prototype.check = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  return bulk._request({\r\n    method : 'GET',\r\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\r\n    responseType: \"application/xml\"\r\n  }).then(function(res) {\r\n    logger.debug(res.batchInfo);\r\n    return res.batchInfo;\r\n  }).thenCall(callback);\r\n};\r\n\r\n\r\n/**\r\n * Polling the batch result and retrieve\r\n *\r\n * @method Bulk~Batch#poll\r\n * @param {Number} interval - Polling interval in milliseconds\r\n * @param {Number} timeout - Polling timeout in milliseconds\r\n */\r\nBatch.prototype.poll = function(interval, timeout) {\r\n  var self = this;\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  var startTime = new Date().getTime();\r\n  var poll = function() {\r\n    var now = new Date().getTime();\r\n    if (startTime + timeout < now) {\r\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\r\n      err.name = 'PollingTimeout';\r\n      err.jobId = jobId;\r\n      err.batchId = batchId;\r\n      self.emit('error', err);\r\n      return;\r\n    }\r\n    self.check(function(err, res) {\r\n      if (err) {\r\n        self.emit('error', err);\r\n      } else {\r\n        if (res.state === \"Failed\") {\r\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\r\n            self.retrieve();\r\n          } else {\r\n            self.emit('error', new Error(res.stateMessage));\r\n          }\r\n        } else if (res.state === \"Completed\") {\r\n          self.retrieve();\r\n        } else {\r\n          self.emit('progress', res);\r\n          if (self.pollHandle) {\r\n            self.pollHandle = setTimeout(poll, interval);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  };\r\n  this.pollHandle = setTimeout(poll, interval);\r\n};\r\n\r\n/**\r\n * Stops polling the current batch for progress. Call this to stop `poll` and break the polling loop.\r\n */\r\nBatch.prototype.pollStop = function() {\r\n  if (!this.pollHandle) {\r\n    throw new Error(\"Polling not started.\");\r\n  }\r\n  clearTimeout(this.pollHandle);\r\n  this.pollHandle = undefined;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Bulk~BatchResultInfo\r\n * @prop {String} id - Batch result ID\r\n * @prop {String} batchId - Batch ID which includes this batch result.\r\n * @prop {String} jobId - Job ID which includes this batch result.\r\n */\r\n\r\n/**\r\n * Retrieve batch result\r\n *\r\n * @method Bulk~Batch#retrieve\r\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\r\n */\r\nBatch.prototype.retrieve = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var jobId = this.job.id;\r\n  var job = this.job;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n\r\n  return job.info().then(function(jobInfo) {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\r\n    });\r\n  }).then(function(res) {\r\n    var results;\r\n    if (job.operation === 'query') {\r\n      var conn = bulk._conn;\r\n      var resultIds = res['result-list'].result;\r\n      results = res['result-list'].result;\r\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\r\n        return {\r\n          id: id,\r\n          batchId: batchId,\r\n          jobId: jobId\r\n        };\r\n      });\r\n    } else {\r\n      results = _.map(res, function(ret) {\r\n        return {\r\n          id: ret.Id || null,\r\n          success: ret.Success === \"true\",\r\n          errors: ret.Error ? [ ret.Error ] : []\r\n        };\r\n      });\r\n    }\r\n    self.emit('response', results);\r\n    return results;\r\n  }).fail(function(err) {\r\n    self.emit('error', err);\r\n    throw err;\r\n  }).thenCall(callback);\r\n};\r\n\r\n/**\r\n * Fetch query result as a record stream\r\n * @param {String} resultId - Result id\r\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\r\n */\r\nBatch.prototype.result = function(resultId) {\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  var resultStream = new RecordStream.Parsable();\r\n  var resultDataStream = resultStream.stream('csv');\r\n  var reqStream = this._bulk._request({\r\n    method : 'GET',\r\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId,\r\n    responseType: \"application/octet-stream\"\r\n  }).stream().pipe(resultDataStream);\r\n  return resultStream;\r\n};\r\n\r\n/*--------------------------------------------*/\r\n/**\r\n * @private\r\n */\r\nvar BulkApi = function() {\r\n  BulkApi.super_.apply(this, arguments);\r\n};\r\n\r\ninherits(BulkApi, HttpApi);\r\n\r\nBulkApi.prototype.beforeSend = function(request) {\r\n  request.headers = request.headers || {};\r\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\r\n};\r\n\r\nBulkApi.prototype.isSessionExpired = function(response) {\r\n  return response.statusCode === 400 &&\r\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\r\n};\r\n\r\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\r\n  return !!body.error;\r\n};\r\n\r\nBulkApi.prototype.parseError = function(body) {\r\n  return {\r\n    errorCode: body.error.exceptionCode,\r\n    message: body.error.exceptionMessage\r\n  };\r\n};\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Class for Bulk API\r\n *\r\n * @class\r\n * @param {Connection} conn - Connection object\r\n */\r\nvar Bulk = function(conn) {\r\n  this._conn = conn;\r\n  this._logger = conn._logger;\r\n};\r\n\r\n/**\r\n * Polling interval in milliseconds\r\n * @type {Number}\r\n */\r\nBulk.prototype.pollInterval = 1000;\r\n\r\n/**\r\n * Polling timeout in milliseconds\r\n * @type {Number}\r\n */\r\nBulk.prototype.pollTimeout = 10000;\r\n\r\n/** @private **/\r\nBulk.prototype._request = function(request, callback) {\r\n  var conn = this._conn;\r\n  request = _.clone(request);\r\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\r\n  request.url = baseUrl + request.path;\r\n  var options = { responseType: request.responseType };\r\n  delete request.path;\r\n  delete request.responseType;\r\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\r\n};\r\n\r\n/**\r\n * Create and start bulkload job and batch\r\n *\r\n * @param {String} type - SObject type\r\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\r\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\r\n * @param {Boolean} [options.pkChunking] - Enables PK Chunking for Bulk API Query. Defaults to false. Use chunkSize to change the default chunk size.\r\n * @param {Number} [options.chunkSize] - Chunk size for `pkChunking`; when set forces PK Chunking to to true.\r\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\r\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Bulk~Batch}\r\n */\r\nBulk.prototype.load = function(type, operation, options, input, callback) {\r\n  var self = this;\r\n  if (!type || !operation) {\r\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\r\n  }\r\n  if (!_.isObject(options) || options.constructor !== Object) { // when options is not plain hash object, it is omitted\r\n    callback = input;\r\n    input = options;\r\n    options = null;\r\n  }\r\n  var job = this.createJob(type, operation, options);\r\n  var isChunking = options.pkChunking || options.chunkSize;\r\n  job.once('error', function (error) {\r\n    if (batch) {\r\n      batch.emit('error', error); // pass job error to batch\r\n    }\r\n  });\r\n  var batch = job.createBatch();\r\n  var cleanup = function() {\r\n    batch = null;\r\n    job.close();\r\n  };\r\n  var cleanupOnError = function(err) {\r\n    if (err.name !== 'PollingTimeout') {\r\n      cleanup();\r\n    }\r\n  };\r\n  if (isChunking) {\r\n    var retrieveAll = function(batches) {\r\n      var results = Promise.all(batches.map(function(info) {\r\n        return job.batch(info.id).retrieve();\r\n      }));\r\n      results.then(function(res) { \r\n        batch.emit('response', _.flatten(res));\r\n      }, function(err) { \r\n        self.emit('error', err);\r\n      });\r\n      return results;\r\n    };\r\n    var pollBatches = function() {\r\n      job.list(function(err, batches) { \r\n        if (!err) {\r\n          batches = batches.filter(function(info) { return info.id != batch.id; });\r\n          var allCompleted = batches.every(function(info) { return info.state == 'Completed'; });     \r\n          if (allCompleted) {\r\n            retrieveAll(batches);\r\n          } else {\r\n            var failedBatch = batches.find(function(info) { return info.state == 'Failed'; });\r\n            if (failedBatch) {\r\n              self.emit('error', new Error(failedBatch.stateMessage));\r\n            } else {\r\n              setTimeout(pollBatches, self.pollInterval);\r\n            }\r\n          }\r\n        } else {\r\n          self.emit('error', error);\r\n        }\r\n      });\r\n    };\r\n    var handleProgress = function(progress) { \r\n      if (progress.state == \"NotProcessed\") {\r\n        batch.pollStop();\r\n        pollBatches();\r\n      }\r\n    };\r\n    batch.on('progress', handleProgress);\r\n  }\r\n  batch.on('response', cleanup);\r\n  batch.on('error', cleanupOnError);\r\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\r\n  return batch.execute(input, callback);\r\n};\r\n\r\n/**\r\n * Execute bulk query and get record stream\r\n *\r\n * @param {String} soql - SOQL to execute in bulk job\r\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\r\n */\r\nBulk.prototype.query = function(soql, options) {\r\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\r\n  if (!m) {\r\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\r\n  }\r\n  var type = m[1];\r\n  var self = this;\r\n  var recordStream = new RecordStream.Parsable();\r\n  var dataStream = recordStream.stream('csv');\r\n  this.load(type, \"query\", options, soql).then(function(results) {\r\n    var streams = results.map(function(result) {\r\n      var job = self.job(result.jobId);\r\n      return function() { \r\n        return job\r\n          .batch(result.batchId)\r\n          .result(result.id)\r\n          .stream();\r\n      };\r\n    });\r\n\r\n    joinStreams(streams).pipe(dataStream);\r\n  }).fail(function(err) {\r\n    recordStream.emit('error', err);\r\n  });\r\n  return recordStream;\r\n};\r\n\r\n\r\n/**\r\n * Create a new job instance\r\n *\r\n * @param {String} type - SObject type\r\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @returns {Bulk~Job}\r\n */\r\nBulk.prototype.createJob = function(type, operation, options) {\r\n  return new Job(this, type, operation, options);\r\n};\r\n\r\n/**\r\n * Get a job instance specified by given job ID\r\n *\r\n * @param {String} jobId - Job ID\r\n * @returns {Bulk~Job}\r\n */\r\nBulk.prototype.job = function(jobId) {\r\n  return new Job(this, null, null, null, jobId);\r\n};\r\n\r\n\r\n/*--------------------------------------------*/\r\n/*\r\n * Register hook in connection instantiation for dynamically adding this API module features\r\n */\r\njsforce.on('connection:new', function(conn) {\r\n  conn.bulk = new Bulk(conn);\r\n});\r\n\r\n\r\nmodule.exports = Bulk;\r\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"]}